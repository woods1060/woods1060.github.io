<h1 id="compound第62提案升级导致奖励分发过多"><a href="#compound第62提案升级导致奖励分发过多" class="headerlink" title="compound第62提案升级导致奖励分发过多"></a>compound第62提案升级导致奖励分发过多</h1><p><img src="F:\dfile\ctf\安全blog\compound\Snipaste_2021-10-11_15-29-33.png" alt="Snipaste_2021-10-11_15-29-33"></p>
<p>Compound创始人表示：该漏洞是由于Compound的62次提案升级所导致。</p>
<ul>
<li><p><code>Comptroller#compSpeeds</code> storage variable is no longer being used and has been effectively deleted. It’s replaced by <code>Comptroller#compBorrowSpeeds</code> and <code>Comptroller#compSupplySpeeds</code>. This proposal copies the current rates into the new storage variables.</p>
</li>
<li><p><code>Comptroller#_setCompSpeed(CToken,uint256)</code> function has been removed and replaced by <code>Comptroller#_setCompSpeeds(CToken[],uint256[],uint256[])</code>. This new function allows COMP rewards rates for multiple markets to be set with a single call.</p>
</li>
<li><p>An upgrade hook initializes all non-initialized market state indices (initial index is 1e36).</p>
</li>
<li><p>When new markets are added, their state indices are now properly initialized (used to use lazy initialization which caused many problems).</p>
<h4 id="升级主要做了以下改变："><a href="#升级主要做了以下改变：" class="headerlink" title="升级主要做了以下改变："></a>升级主要做了以下改变：</h4><p>1.使用 <code>Comptroller#compBorrowSpeeds</code> 和<code>Comptroller#compSupplySpeeds</code>来代替<code>Comptroller#compSpeeds</code>storage类型变量；</p>
<p>2.<code>Comptroller#_setCompSpeeds(CToken[],uint256[],uint256[])</code>来对<code>Comptroller#_setCompSpeed(CToken,uint256)</code> 进行升级；</p>
<p>3.<em><strong>设定所有新增的初始化的市场状态指数（initial index is 1e36）</strong></em>；</p>
<h5 id="原本设定所有未初始化的市场状态指数是为了解决惰性初始化导致的许多其他问题，来解决之前存在的整数溢出漏洞-（链接1），但是并没有全面考虑到如此的升级对原本的功能的影响！"><a href="#原本设定所有未初始化的市场状态指数是为了解决惰性初始化导致的许多其他问题，来解决之前存在的整数溢出漏洞-（链接1），但是并没有全面考虑到如此的升级对原本的功能的影响！" class="headerlink" title="原本设定所有未初始化的市场状态指数是为了解决惰性初始化导致的许多其他问题，来解决之前存在的整数溢出漏洞 （链接1），但是并没有全面考虑到如此的升级对原本的功能的影响！"></a>原本设定所有未初始化的市场状态指数是为了解决惰性初始化导致的许多其他问题，来解决之前存在的整数溢出漏洞 （链接1），但是并没有全面考虑到如此的升级对原本的功能的影响！</h5><p><img src="F:\dfile\ctf\安全blog\compound\Snipaste_2021-10-11_16-11-53.png" alt="Snipaste_2021-10-11_16-11-53"></p>
<h5 id="该漏洞产生的条件：需要在62次提案更新之前与某些特定代币（cSAI、cTUSD、cMKR、cSUSHI、cAAVE、cYFI）进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。"><a href="#该漏洞产生的条件：需要在62次提案更新之前与某些特定代币（cSAI、cTUSD、cMKR、cSUSHI、cAAVE、cYFI）进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。" class="headerlink" title="该漏洞产生的条件：需要在62次提案更新之前与某些特定代币（cSAI、cTUSD、cMKR、cSUSHI、cAAVE、cYFI）进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。"></a>该漏洞产生的条件：需要在62次提案更新之前与某些特定代币（cSAI、cTUSD、cMKR、cSUSHI、cAAVE、cYFI）进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。</h5><p>我们已其中一个交易为例进行分析：<a href="https://etherscan.io/tx/0xee318650ae8bcf83517e77e8654d40201990080fcb888087f737aea28e70bdb1">https://etherscan.io/tx/0xee318650ae8bcf83517e77e8654d40201990080fcb888087f737aea28e70bdb1</a></p>
<p><img src="F:\dfile\ctf\安全blog\compound\image-20211012132817404.png" alt="image-20211012132817404"></p>
<p>获利者地址为（0xab5a193a11f779fe105e8edf9815a0b514b013ca），通过claimCmop函数来提取收益，但是却获得了22,995.930896459946832819 枚comp的收益，这个数字远远大于应获得的收益。</p>
<p><img src="F:\dfile\ctf\安全blog\compound\Snipaste_2021-10-12_13-38-12.png" alt="Snipaste_2021-10-12_13-38-12"></p>
<p>通过交易追踪发现，该获利者在领取借贷代币（cUSDT）的奖励时，获得了大量的comp代币（ 22,995.425435193061317525枚）。</p>
<p><img src="F:\dfile\ctf\安全blog\compound\Snipaste_2021-10-12_13-44-47.png" alt="Snipaste_2021-10-12_13-44-47"></p>
<p>用户借贷comp奖励的公式为：borrowerAmount * deltaIndex（即：借款数量*奖励因子）。</p>
<p>deltaIndex = borrowIndex - borrowerIndex（奖励因子 = 池借贷指数 - 用户借贷指数），由于第62次提案的升级，cUSDT池借贷指数被初始化为 compInitialIndex （1e36），而此时用户的借贷指数为0，导致算出的奖励因子deltaIndex非常大为1e36。合约正常逻辑应该先通过if (borrowerIndex == 0 &amp;&amp; borrowIndex &gt; = compInitialIndex) 该分支的判断，使用户的借贷指数进行更新为compInitialIndex（1e36），才可以进行奖励的计算！此处由于 borrowIndex &gt; compInitialIndex（缺少等号） 导致绕过该判断，直接进行奖励计算，导致奖励因子计算出的值非常的大。</p>
<p><img src="F:\dfile\ctf\安全blog\compound\Snipaste_2021-10-12_14-01-25.png" alt="Snipaste_2021-10-12_14-01-25"></p>
<p><img src="F:\dfile\ctf\安全blog\compound\Snipaste_2021-10-12_14-05-13.png" alt="Snipaste_2021-10-12_14-05-13"></p>
<p>该用户在62次更新之前的一笔cUSDT的借款，为其带来了22,995枚comp的”收益“。</p>
<h5 id="因此该漏洞并不是任何人都可以获利，需要在62次提案更新之前与某些特定代币进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。"><a href="#因此该漏洞并不是任何人都可以获利，需要在62次提案更新之前与某些特定代币进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。" class="headerlink" title="因此该漏洞并不是任何人都可以获利，需要在62次提案更新之前与某些特定代币进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。"></a>因此该漏洞并不是任何人都可以获利，需要在62次提案更新之前与某些特定代币进行存款或借款，并留有一定的余额，就可以获得大量的comp收益奖励。</h5><p><img src="F:\dfile\ctf\安全blog\compound\Snipaste_2021-10-12_14-13-54.png" alt="Snipaste_2021-10-12_14-13-54"></p>
<p>通过更新提案可知，这些特定代币为cTUSD、cAAVE、cSAI、cSUSHI、cMKR、cYFI这6种代币，其池借贷指数和存款指数均被初始化为1e36！</p>
<h5 id="后续："><a href="#后续：" class="headerlink" title="后续："></a>后续：</h5><p>​        <img src="F:\dfile\ctf\安全blog\compound\Snipaste_2021-10-12_14-29-27.png" alt="Snipaste_2021-10-12_14-29-27"></p>
<p>Compound创始人表示拿出多出来收益的10%作为白帽奖励，希望获利的用户可以归还多出来的奖励，并通过提案63，64对问题进行修复。</p>
<h5 id="启示："><a href="#启示：" class="headerlink" title="*启示：*"></a><em><strong>*启示：*</strong></em></h5><p>  Compound虽然通过DAO的管理模式进行自治，但是在每次进行协议提案升级之前是否进行充分的安全性验证？当问题突发时，需要一定的提案过程与时间才可以对问题进行修复，充分暴露了对突发问题机动能力不足等问题！</p>
</li>
</ul>
